'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2016 Hideki Shiro
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _opentype = require('opentype.js');

var opentype = _interopRequireWildcard(_opentype);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DEFAULT_FONT = require('path').join(__dirname, '../fonts/ipag.ttf');

// Private method

function parseAnchorOption(anchor) {
  var horizontal = anchor.match(/left|center|right/gi) || [];
  horizontal = horizontal.length === 0 ? 'left' : horizontal[0];

  var vertical = anchor.match(/baseline|top|bottom|middle/gi) || [];
  vertical = vertical.length === 0 ? 'baseline' : vertical[0];

  return { horizontal: horizontal, vertical: vertical };
}

var TextToSVG = function () {
  function TextToSVG(font) {
    _classCallCheck(this, TextToSVG);

    this.font = font;
  }

  _createClass(TextToSVG, [{
    key: 'getFontSize',


    // Given text and width, return fontSize needed
    // to get that width.
    // This is basically the inverse of getWidth() function
    value: function getFontSize(text, width) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var kerning = 'kerning' in options ? options.kerning : true;

      var fontSizeMultiplier = 0;
      var glyphs = this.font.stringToGlyphs(text);
      for (var i = 0; i < glyphs.length; i++) {
        var glyph = glyphs[i];

        if (glyph.advanceWidth) {
          fontSizeMultiplier += glyph.advanceWidth * 1 / this.font.unitsPerEm;
        }

        if (kerning && i < glyphs.length - 1) {
          var kerningValue = this.font.getKerningValue(glyph, glyphs[i + 1]);
          fontSizeMultiplier += kerningValue * 1 / this.font.unitsPerEm;
        }

        if (options.letterSpacing) {
          fontSizeMultiplier += options.letterSpacing;
        } else if (options.tracking) {
          fontSizeMultiplier += options.tracking / 1000;
        }
      }

      return width / fontSizeMultiplier;
    }
  }, {
    key: 'getWidth',
    value: function getWidth(text, options) {
      var fontSize = options.fontSize || 72;
      var kerning = 'kerning' in options ? options.kerning : true;
      var fontScale = 1 / this.font.unitsPerEm * fontSize;

      var width = 0;
      var glyphs = this.font.stringToGlyphs(text);
      for (var i = 0; i < glyphs.length; i++) {
        var glyph = glyphs[i];

        if (glyph.advanceWidth) {
          width += glyph.advanceWidth * fontScale;
        }

        if (kerning && i < glyphs.length - 1) {
          var kerningValue = this.font.getKerningValue(glyph, glyphs[i + 1]);
          width += kerningValue * fontScale;
        }

        if (options.letterSpacing) {
          width += options.letterSpacing * fontSize;
        } else if (options.tracking) {
          width += options.tracking / 1000 * fontSize;
        }
      }
      return width;
    }
  }, {
    key: 'getHeight',
    value: function getHeight(fontSize) {
      var fontScale = 1 / this.font.unitsPerEm * fontSize;
      return (this.font.ascender - this.font.descender) * fontScale;
    }
  }, {
    key: 'getMetrics',
    value: function getMetrics(text) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var fontSize = options.fontSize || 72;
      var anchor = parseAnchorOption(options.anchor || '');

      var width = this.getWidth(text, options);
      var height = this.getHeight(fontSize);

      var fontScale = 1 / this.font.unitsPerEm * fontSize;
      var ascender = this.font.ascender * fontScale;
      var descender = this.font.descender * fontScale;

      var x = options.x || 0;
      switch (anchor.horizontal) {
        case 'left':
          x -= 0;
          break;
        case 'center':
          x -= width / 2;
          break;
        case 'right':
          x -= width;
          break;
        default:
          throw new Error('Unknown anchor option: ' + anchor.horizontal);
      }

      var y = options.y || 0;
      switch (anchor.vertical) {
        case 'baseline':
          y -= ascender;
          break;
        case 'top':
          y -= 0;
          break;
        case 'middle':
          y -= height / 2;
          break;
        case 'bottom':
          y -= height;
          break;
        default:
          throw new Error('Unknown anchor option: ' + anchor.vertical);
      }

      var baseline = y + ascender;

      return {
        x: x,
        y: y,
        baseline: baseline,
        width: width,
        height: height,
        ascender: ascender,
        descender: descender
      };
    }
  }, {
    key: 'getD',
    value: function getD(text) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var fontSize = options.fontSize || 72;
      var kerning = 'kerning' in options ? options.kerning : true;
      var letterSpacing = 'letterSpacing' in options ? options.letterSpacing : false;
      var tracking = 'tracking' in options ? options.tracking : false;
      var metrics = this.getMetrics(text, options);
      var path = this.font.getPath(text, metrics.x, metrics.baseline, fontSize, { kerning: kerning, letterSpacing: letterSpacing, tracking: tracking });

      return {
        data: path.toPathData(),
        boundingBox: path.getBoundingBox()
      };
    }
  }, {
    key: 'getPath',
    value: function getPath(text) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var attributes = Object.keys(options.attributes || {}).map(function (key) {
        return key + '="' + options.attributes[key] + '"';
      }).join(' ');
      var d = this.getD(text, options);

      var data;
      if (attributes) {
        data = '<path ' + attributes + ' d="' + d.data + '"/>';
      } else {
        data = '<path d="' + d.data + '"/>';
      }

      return {
        data: data,
        boundingBox: d.boundingBox
      };
    }
  }, {
    key: 'getSVG',
    value: function getSVG(text) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var metrics = this.getMetrics(text, options);
      var path = this.getPath(text, options);
      var bb = path.boundingBox;
      var svg = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="' + metrics.width + '" height="' + metrics.height + '" viewBox="' + bb.x1 + ' ' + bb.y1 + ' ' + bb.x2 + ' ' + bb.y2 + '">';
      svg += path.data;
      svg += '</svg>';

      return svg;
    }
  }, {
    key: 'getDebugSVG',
    value: function getDebugSVG(text) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      options = JSON.parse(JSON.stringify(options));

      options.x = options.x || 0;
      options.y = options.y || 0;
      var metrics = this.getMetrics(text, options);
      var box = {
        width: Math.max(metrics.x + metrics.width, 0) - Math.min(metrics.x, 0),
        height: Math.max(metrics.y + metrics.height, 0) - Math.min(metrics.y, 0)
      };
      var origin = {
        x: box.width - Math.max(metrics.x + metrics.width, 0),
        y: box.height - Math.max(metrics.y + metrics.height, 0)
      };

      // Shift text based on origin
      options.x += origin.x;
      options.y += origin.y;

      var path = this.getPath(text, options);
      var boundingBox = path.boundingBox;

      var svg = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="' + box.width + '" height="' + box.height + '">';
      svg += '<path fill="none" stroke="red" stroke-width="1" d="M0,' + origin.y + 'L' + box.width + ',' + origin.y + '"/>'; // X Axis
      svg += '<path fill="none" stroke="red" stroke-width="1" d="M' + origin.x + ',0L' + origin.x + ',' + box.height + '"/>'; // Y Axis
      svg += path.data;
      svg += '</svg>';

      return svg;
    }
  }], [{
    key: 'loadSync',
    value: function loadSync() {
      var file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_FONT;

      return new TextToSVG(opentype.loadSync(file));
    }
  }, {
    key: 'load',
    value: function load(url, cb) {
      opentype.load(url, function (err, font) {
        if (err !== null) {
          return cb(err, null);
        }

        return cb(null, new TextToSVG(font));
      });
    }
  }]);

  return TextToSVG;
}();

exports.default = TextToSVG;


module.exports = exports.default;